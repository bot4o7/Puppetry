
//========================================================================
// OpenGL triangle example
// Copyright (c) Camilla Löwy <elmindreda@glfw.org>
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would
//    be appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not
//    be misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source
//    distribution.
//
//========================================================================
//! [code]

// Step 1
// Including the GLFW header
// 包括 GLFW 标头
// In the source files of your application where you use GLFW, you need to include its header file.
// 在使用 GLFW 的应用程序的源文件中，您需要包含其头文件。
// This header provides all the constants, types and  function prototypes of the GLFW API.
// 该标头提供了 GLFW API 的所有常量、类型和函数原型。
// 
// By default it also includes the OpenGL header from your  development environment.On some platforms this header  only supports older versions of OpenGL.The most extreme case is /Windows, where it typically only supports  OpenGL 1.2.
// 默认情况下，它还包含来自开发环境的 OpenGL 标头。在某些平台上，此标头 仅支持旧版本的 OpenGL。最极端的情况是 Windows，它通常仅支持 OpenGL 1.2。
// 
// Most programs will instead use an extension loader  library and include its header.This example uses files  generated by glad.The GLFW header can detect most such  headers if they are included first and will then not  include the one from your development environment.
// 大多数程序将改为使用扩展加载器库并包含其标头。这个例子使用了glad生成的文件。 GLFW 标头可以检测大多数此类标头（如果首先包含这些标头），然后不会包含来自您的开发环境的标头。
// To make sure there will be no header conflicts, you can define GLFW_INCLUDE_NONE before the GLFW header to  explicitly disable inclusion of the development  environment header.This also allows the two headers to  be included in any order.
// 为了确保不会出现标头冲突，您可以在 GLFW 标头之前定义  GLFW_INCLUDE_NONE 以显式禁用开发环境标头的包含。这也允许以任意顺 序包含两个标头。
// #define GLFW_INCLUDE_NONE
// #include <GLFW/glfw3.h>
// #include <glad/glad.h>
//#define GLAD_GL_IMPLEMENTATION
#include <glad/glad.h>
//#include <glad/gl.h>
//#define GLFW_INCLUDE_NONE
#include <GLFW/glfw3.h>

#include "linmath.h"

//#include <stdlib.h>
#include <cstdlib>
//#include <stddef.h>
#include <cstddef>
//#include <stdio.h>
#include <cstdio>

// Step triangle-opengl.1
typedef struct Vertex
{
	vec2 pos;
	vec3 col;
} Vertex;
static const Vertex vertices[3] =
{
	{ { -0.6f, -0.4f }, { 1.f, 0.f, 0.f } },
	{ {  0.6f, -0.4f }, { 0.f, 1.f, 0.f } },
	{ {   0.f,  0.6f }, { 0.f, 0.f, 1.f } }
};
static const char* vertex_shader_text =
"#version 330\n"
"uniform mat4 MVP;\n"
"in vec3 vCol;\n"
"in vec2 vPos;\n"
"out vec3 color;\n"
"void main()\n"
"{\n"
"    gl_Position = MVP * vec4(vPos, 0.0, 1.0);\n"
"    color = vCol;\n"
"}\n";
static const char* fragment_shader_text =
"#version 330\n"
"in vec3 color;\n"
"out vec4 fragment;\n"
"void main()\n"
"{\n"
"    fragment = vec4(color, 1.0);\n"
"}\n";

// Step 3.1
// 详见函数定义
// 错误回调函数的声明 declaration of error callback function
void error_callback(int error, const char* description);

// Step 7.1
// 详见函数定义
// 键盘事件回调函数的声明
static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods);


int main()
{
	// Step 3.3
		// Callback functions must be set, so GLFW knows to call them. The function to set the error callback is one of the few GLFW functions that may be called before initialization, which lets you be notified of errors both during and after initialization.
		// 必须设置回调函数，以便 GLFW 知道调用它们。设置错误回调的函数是少数可以在初始化之前调用的 GLFW 函数之一，它可以让您在初始化期间和之后收到错误通知。
			// Setting an error callback
			// 为 GLFW 设置错误回调函数
	glfwSetErrorCallback(error_callback);

	// Setp 2.1
	// Initializing and terminating GLFW
	// 初始化和终止 GLFW
	// Before you can use most GLFW functions, the library must be initialized.On successful initialization, GLFW_TRUE is returned.If an error occurred, GLFW_FALSE is returned.
	// 在使用大多数 GLFW 函数之前，必须初始化该库。成功初始化后，将返回 GLFW_TRUE 。如果发生错误，则返回 GLFW_FALSE 。
	// Note that GLFW_TRUE and GLFW_FALSE are and will always be one and zero.
	// 请注意， GLFW_TRUE 和 GLFW_FALSE 始终是1 和0。
	if (!glfwInit()) {
		// Initialization failed
		// 初始化失败
		fprintf(stderr, "Initialization failed.\n");
		fprintf(stderr, "初始化失败...\n\n");

		glfwTerminate();
		exit(EXIT_FAILURE);
	}

	// Step 4.1
	// Creating a window and context
	// 创建窗口和上下文
	// The window and its OpenGL context are created with a single call to glfwCreateWindow, which returns a handle to the created combined window and context object
	// 窗口及其 OpenGL 上下文是通过一次调用 glfwCreateWindow 创建的，该调用返回所创建的组合窗口和上下文对象的句柄
	// 
	// This creates a 640 by 480 windowed mode window with an OpenGL context. If window or OpenGL context creation fails, NULL will be returned. You should always check the return value. While window creation rarely fails, context creation depends on properly installed drivers and may fail even on machines with the necessary hardware.
	// 这将创建一个带有 OpenGL 上下文的 640 x 480 窗口模式窗口。如果窗口或 OpenGL 上下文创建失败，将返回 NULL 。您应该始终检查返回值。虽然窗口创建很少失败，但上下文创建取决于正确安装的驱动程序，甚至在具有必要硬件的计算机上也可能失败。
	//
	// By default, the OpenGL context GLFW creates may have any version.You can require a minimum OpenGL version by setting the GLFW_CONTEXT_VERSION_MAJOR and GLFW_CONTEXT_VERSION_MINOR hints before creation.If the required minimum version is not supported on the machine, context(and window) creation fails.
	// 默认情况下，GLFW 创建的 OpenGL 上下文可以有任何版本。您可以通过在创建之前设置 GLFW_CONTEXT_VERSION_MAJOR 和 GLFW_CONTEXT_VERSION_MINOR 提示来要求最低 OpenGL 版本。如果计算机不支持所需的最低版本，则上下文（和窗口）创建将失败。
	//
	// You can select the OpenGL profile by setting the GLFW_OPENGL_PROFILE hint.This program uses the core profile as that is the only profile macOS supports for OpenGL 3.x and 4.x.
	// 您可以通过设置 GLFW_OPENGL_PROFILE 提示来选择OpenGL配置文件。该程序使用核心配置文件，因为这是 macOS 支持 OpenGL 3.x 和 4.x 的唯一配置文件。
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	GLFWwindow* window = glfwCreateWindow(640, 480, "My Title", NULL, NULL);
	if (!window) {
		// Window or OpenGL context creation failed
		// 窗口或 OpenGL 上下文创建失败

		fprintf(stderr, "Window or OpenGL context creation failed.\n");
		fprintf(stderr, "窗口或OpenGL上下文创建失败...\n\n");
	}

	// Step 6.2
	// 教程没说这个 glfwSetKeyCallback()该放哪里，我觉得应该是放在 while (!glfwWindowShouldClose(window)) 循环之前，就像 error callback 一样
	// You can be notified when the user is attempting to close the window by setting a close callback with glfwSetWindowCloseCallback. The callback will be called immediately after the close flag has been set.
	// 通过使用 glfwSetWindowCloseCallback 设置关闭回调，您可以在用户尝试关闭窗口时收到通知。设置关闭标志后将立即调用回调。
	// The key callback, like other window related callbacks, are set per - window.
	// 与其他窗口相关的回调一样，键回调是为每个窗口设置的。
	// 这个回调函数你可以自己写个啥
	//glfwSetWindowCloseCallback();

	// Step 7.3
	// The key callback, like other window related callbacks, are set per - window.
	// 与其他窗口相关的回调一样，键回调是为每个窗口设置的。
	glfwSetKeyCallback(window, key_callback);

	// Step 5.1
	// Making the OpenGL context current
	// 使 OpenGL 上下文成为当前上下文
	// Before you can use the OpenGL API, you must have a current OpenGL context.
	// 在使用 OpenGL API 之前，您必须具有当前的 OpenGL 上下文。
	// The context will remain current until you make another context current or until the window owning the current context is destroyed.
	// 该上下文将保持当前状态，直到您将另一个上下文设置为当前上下文或直到拥有当前上下文的窗口被销毁。
	glfwMakeContextCurrent(window);

	// Step 5.2
	// If you are using an extension loader library to access modern OpenGL then this is when to initialize it, as the loader needs a current context to load from. This example uses glad, but the same rule applies to all such libraries.
	// 如果您使用扩展加载器库来访问现代 OpenGL，那么此时就需要对其进行初始化，因为加载器需要从中加载当前上下文。此示例使用glad，但相同的规则适用于所有此类库。
	//gladLoadGL(glfwGetProcAddress); // 这里报错，gladLoadGL() 没有参数，不能传东西进去
	// 方案一:
	//gladLoadGL(); 
	// 方案二:
	//gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
	gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
	//gladLoadGL(glfwGetProcAddress);
	//gladLoadGL();

	// Step 10.2
	// The swap interval indicates how many frames to wait until swapping the buffers, commonly known as vsync. By default, the swap interval is zero, meaning buffer swapping will occur immediately. On fast machines, many of those frames will never be seen, as the screen is still only updated typically 60-75 times per second, so this wastes a lot of CPU and GPU cycles.
	// 交换间隔指示交换缓冲区之前要等待多少帧，通常称为垂直同步。默认情况下，交换间隔为零，这意味着缓冲区交换将立即发生。在快速机器上，许多帧将永远不会被看到，因为屏幕通常每秒仅更新 60 - 75 次，因此这会浪费大量 CPU 和 GPU 周期。
	//
	// Also, because the buffers will be swapped in the middle the screen update, leading to screen tearing.
	// 此外，由于缓冲区将在屏幕更新过程中交换，导致屏幕撕裂。
	//
	//For these reasons, applications will typically want to set the swap interval to one.It can be set to higher values, but this is usually not recommended, because of the input latency it leads to.
	//由于这些原因，应用程序通常希望将交换间隔设置为 1。它可以设置为更高的值，但通常不建议这样做，因为它会导致输入延迟。
	//
	// This function acts on the current context and will fail unless a context is current.   eg. glfwMakeContextCurrent(window);
	// 该函数作用于当前上下文，除非上下文是当前的，否则将会失败。  例如，glfwMakeContextCurrent(window);
	glfwSwapInterval(1);

	// Step triangle-opengl.2
	GLuint vertex_buffer;
	glGenBuffers(1, &vertex_buffer);
	glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

	const GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertex_shader, 1, &vertex_shader_text, NULL);
	glCompileShader(vertex_shader);

	const GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragment_shader, 1, &fragment_shader_text, NULL);
	glCompileShader(fragment_shader);

	const GLuint program = glCreateProgram();
	glAttachShader(program, vertex_shader);
	glAttachShader(program, fragment_shader);
	glLinkProgram(program);

	const GLint mvp_location = glGetUniformLocation(program, "MVP");
	const GLint vpos_location = glGetAttribLocation(program, "vPos");
	const GLint vcol_location = glGetAttribLocation(program, "vCol");

	GLuint vertex_array;
	glGenVertexArrays(1, &vertex_array);
	glBindVertexArray(vertex_array);
	glEnableVertexAttribArray(vpos_location);
	glVertexAttribPointer(vpos_location, 2, GL_FLOAT, GL_FALSE,
		sizeof(Vertex), (void*)offsetof(Vertex, pos));
	glEnableVertexAttribArray(vcol_location);
	glVertexAttribPointer(vcol_location, 3, GL_FLOAT, GL_FALSE,
		sizeof(Vertex), (void*)offsetof(Vertex, col));

	// Step 6.1
	// Checking the window close flag
	// 检查窗口关闭标志
	// Each window has a flag indicating whether the window should be closed.
	// 每个窗口都有一个标志，指示该窗口是否应该关闭。
	// 
	// When the user attempts to close the window, either by pressing the close widget in the title bar or using a key combination like Alt+F4, this flag is set to 1. Note that the window isn't actually closed, so you are expected to monitor this flag and either destroy the window or give some kind of feedback to the user.
	// 当用户尝试关闭窗口时，无论是通过按标题栏中的关闭小部件还是使用 Alt+F4 等组合键，此标志都会设置为 1。请注意，窗口实际上并未关闭，因此您应该监视此标志并销毁窗口或向用户提供某种反馈。
	// You can also set it yourself with glfwSetWindowShouldClose. This can be useful if you want to interpret other kinds of input as closing the window, like for example pressing the Escape key.
	// 您也可以使用 glfwSetWindowShouldClose 自行设置。如果您想将其他类型的输入解释为关闭窗口（例如按 Escape 键），这可能很有用。
	while (!glfwWindowShouldClose(window)) {
		// Keep running
		// 继续运行

		// Step 8
		// Rendering with OpenGL 使用 OpenGL 渲染
		// Once you have a current OpenGL context, you can use OpenGL normally. In this tutorial, a multicolored rotating triangle will be rendered. The framebuffer size needs to be retrieved for glViewport.
		// 一旦拥有当前的 OpenGL 上下文，就可以正常使用 OpenGL。在本教程中，将渲染一个彩色旋转三角形。需要检索 glViewport 的帧缓冲区大小。
		int width, height;
		glfwGetFramebufferSize(window, &width, &height);
		glViewport(0, 0, width, height);

		// Step triangle-opengl.3
		const float ratio = width / (float)height;
		glClear(GL_COLOR_BUFFER_BIT);

		mat4x4 m, p, mvp;
		mat4x4_identity(m);
		mat4x4_rotate_Z(m, m, (float)glfwGetTime());
		mat4x4_ortho(p, -ratio, ratio, -1.f, 1.f, 1.f, -1.f);
		mat4x4_mul(mvp, p, m);

		glUseProgram(program);
		glUniformMatrix4fv(mvp_location, 1, GL_FALSE, (const GLfloat*)&mvp);
		glBindVertexArray(vertex_array);
		glDrawArrays(GL_TRIANGLES, 0, 3);

		// Step 8.2
		// You can also set a framebuffer size callback using glfwSetFramebufferSizeCallback and be notified when the size changes.
		// 您还可以使用 glfwSetFramebufferSizeCallback 设置帧缓冲区大小回调，并在大小更改时收到通知。
		//
		// The details of how to render with OpenGL is outside the scope of this tutorial, but there are many excellent resources for learning modern OpenGL. Here are a few of them:
		// 如何使用 OpenGL 进行渲染的详细信息超出了本教程的范围，但是有许多用于学习现代 OpenGL 的优秀资源。这里有几个：
		// https://antongerdelan.net/opengl/  Anton 的 OpenGL 4 教程
		// https://learnopengl.com/  Learn OpenGL  学习OpenGL
		// https://open.gl/   Open.GL  开放式语言
		// These all happen to use GLFW, but OpenGL itself works the same whatever API you use to create the window and context.
		// 这些都恰好使用 GLFW，但无论您使用什么 API 创建窗口和上下文，OpenGL 本身的工作原理都是相同的。

		// Step 9
		// Reading the timer 读取定时器
		// To create smooth animation, a time source is needed.GLFW provides a timer that returns the number of seconds since initialization.The time source used is the most accurate on each platform and generally has micro - or nanosecond resolution.
		// 要创建流畅的动画，需要时间源。 GLFW 提供了一个计时器，用于返回自初始化以来的秒数。使用的时间源在每个平台上都是最准确的，并且通常具有微秒或纳秒分辨率。
		// 绘制的这个三角形好像是静态的，不需要平移等变换，也就无需动画，所以没用上这个 time ？
		double time = glfwGetTime();

		// Step 10.1
		// Swapping buffers  交换缓冲区
		// GLFW windows by default use double buffering.That means that each window has two rendering buffers; a front buffer and a back buffer.The front buffer is the one being displayed and the back buffer the one you render to.
		// GLFW 窗口默认使用双缓冲。这意味着每个窗口有两个渲染缓冲区；一个前缓冲区和一个后缓冲区。前缓冲区是正在显示的缓冲区，后缓冲区是您渲染的缓冲区。
		//
		// When the entire frame has been rendered, the buffers need to be swapped with one another, so the back buffer becomes the front buffer and vice versa.
		// 当整个帧渲染完毕后，缓冲区需要相互交换，因此后缓冲区变为前缓冲区，反之亦然。
		glfwSwapBuffers(window);
		// Step 11
		// Processing events 处理事件
		// GLFW needs to communicate regularly with the window system both in order to receive events and to show that the application hasn't locked up. Event processing must be done regularly while you have visible windows and is normally done each frame after buffer swapping.
		// GLFW 需要定期与窗口系统通信，以便接收事件并显示应用程序尚未锁定。当您有可见窗口时，必须定期进行事件处理，并且通常在缓冲区交换后每帧进行一次。
		//
		// There are two methods for processing pending events; polling and waiting.This example will use event polling, which processes only those events that have already been received and then returns immediately.
		//
		// 有两种处理待处理事件的方法；轮询和等待。此示例将使用事件轮询，它仅处理那些已接收到的事件，然后立即返回。
		// This is the best choice when rendering continually, like most games do. If instead you only need to update your rendering once you have received new input, glfwWaitEvents is a better choice. It waits until at least one event has been received, putting the thread to sleep in the meantime, and then processes all received events. This saves a great deal of CPU cycles and is useful for, for example, many kinds of editing tools.
		// 像大多数游戏一样，这是连续渲染时的最佳选择。如果您只需要在收到新输入后更新渲染，则 glfwWaitEvents() 是更好的选择。它会等待，直到至少接收到一个事件，同时使线程休眠，然后处理所有接收到的事件。这可以节省大量的 CPU 周期，并且对于多种编辑工具等非常有用。
		glfwPollEvents();
	}

	// Step 4.2
	// When a window and context is no longer needed, destroy it.
	// 不再需要窗口和上下文时，将其销毁
	// Once this function is called, no more events will be delivered for that window and its handle becomes invalid.
	// 一旦调用此函数，将不会再为该窗口传递任何事件，并且其句柄将变为无效。 
	glfwDestroyWindow(window);

	// Setp 2.2
	// When you are done using GLFW, typically just before the application exits, you need to terminate GLFW.
	// Terminate GLFW before app exits
	// 退出程序前，关闭 GLFW
	// This destroys any remaining windows and releases any other resources allocated by GLFW. After this call, you must initialize GLFW again before using any GLFW functions that require it.
	// 这会销毁所有剩余的窗口并释放 GLFW 分配的任何其他资源。在此调用之后，您必须在使用任何需要 GLFW 的函数之前再次初始化 GLFW。
	glfwTerminate();

	// Step triangle-opengl end
	exit(EXIT_SUCCESS);
	return 0;
}

// Step 3.2
// GLFW 使用回调函数来处理按下按键、移动GLFW窗口、发生错误等事件，
// 这些回调函数失败时，会向 “GLFW 错误回调函数  error callback ”报告一个错误 error，
// 我可以用一个 错误回调函数 error callback function 来接收这些报告，
// 比如我创建了一个叫 xxx_func 的函数，这个函数只需要包含 int error, const char* description 两个参数，
// 就可以传递给GLFW： 通过调用 glfwSetErrorCallback( xxx_func );
//
// 例如下面这个函数，就可以作为一个错误回调函数
void error_callback(int error, const char* description)
{
	fprintf(stderr, "Error: %s\n", description);
	fprintf(stderr, "错误: %s\n\n", description);
}

// Step 7.2
// Receiving input events 接收输入事件
// Each window has a large number of callbacks that can be set to receive all the various kinds of events. To receive key press and release events, create a key callback function.
// 每个窗口都有大量的回调，可以设置它们来接收所有各种类型的事件。要接收按键按下和释放事件，请创建按键回调函数。
static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, GLFW_TRUE);
}




